Из журнала Demo or Die #2, 1999



               Radial blur


 (C) Scorpion.

  Задумывались   ли   вы   каким   образом
делается эффект размывки по кругу битмапа?
Иными   словами   фильтрация   битмапа   с
увеличением.  Об  этом  и  пойдёт  речь  в
данной  статье.  Сразу  хочу заметить, что
данная  статья  расчитана  на  более-менее
подготовленного  кодера.  Ввиду  краткости
описания,   буду   приводить   в  основном
алгоритм работы.
  Данный  эффект  состоит из двух основных
подпрограмм,  круговое  увеличение (radial
zoom)  и  фильтрация  (blur).  Radial zoom
получается   следующим   образом.  Вначале
генерируется     массив    полусферической
поверхности,   далее  по  данному  массиву
строится таблица реальных адресов смещений
в  буфере битмапа (look up table). То есть
нам  необходимо  завести  два  массива под
битмапы  и  два  под  таблицы  смещений. И
выполнять  копирование по таблице точек из
одного битмапа в другой.
  Работает     это     так.     В    цикле
последовательно проходим все точки первого
битмапа.   Для   каждой   точки   выбираем
соответствующий    элемент    из   таблицы
смещений.  Она  указывает на точки второго
битмапа,    которые    необходимо   взять.
Kосвенно по данному адресу берём эти точки
и   копируем   в   первый  битмап.  Теперь
объясню,  зачем необходимо было возиться с
массивами  дубликатами.  Дело  в  том, что
если  мы будем копировать точки из битмапа
на  самого  себя,  то  новые  точки  будут
затирать   ещё  нескопированные  старые  и
битмап  будет  постепенно  искажаться. Ещё
один  момент.  Kак  вы уже заметили, точки
копируются не из текущего массива в массив
дубликата,   а  наоборот  из  дубликата  в
текущий.  Дело  в  том, что текущий массив
необходимо   заполнять  линейно,  то  есть
строку  за строкой. Такой подход необходим
для  того,  чтобы  после копирования между
точками в битмапе не было разрывов.
  Теперь  по  поводу генерации таблиц. Для
генерации массива полусферы можно в каждой
точке   X,Y   массива  вычислять  значение
функции:

     Z=(X-Xц)*(X-Xц)+(Y-Yц)*(Y-Yц)

  где Xц,Yц - координаты центра массива.

  В  данном  случае  под  z будем понимать
расстояние   от   экранной   плоскости  до
полусферы.   Получается   некая   аналогия
туннеля.    Теперь   с   помощью   массива
полусферы   необходимо  просчитать  дельта
смещения  точек  в  битмапе.  Сделать  это
можно следующим образом. Hа первом проходе
просчитываем   dX  на  втором  dY.  Дельта
смещение   будет   равно   разности   двух
соседних  значений  функции  полусферы, то
есть:

  dX=Z(x+1,y)-Z(x,y)  dY=Z(x,y+1)-Z(x,y)

  Для нахождения координат смещённых точек
необходимо  к  координатам точек прибавить
дельта  смещения.  Теперь  можно вычислить
реальные адреса смещённых точек:

    Adr=Base+Y*Xmax+X

  где   Base   -   Адрес  второго  массива
битмапа. X,Y - координаты смещённой точки.
Xmax - Длина битмапа по X.

  Данные   адреса  записываются  в  первую
таблицу  смещений. Для формирования второй
таблицы  смещений  можно  к адресам первой
таблицы прибавить константу смещения. Так,
чтобы получилась ссылка на первый битмап.
  После  того, когда ваш битмап увеличился
в   размере   его   необходимо  поблюрить.
Сделать это можно обыкновенным усредняющим
фильтром.   Подробно  про  него  вы  могли
читать  в  DOD#1.  Hапомню, что необходимо
перебирать   все   точки  нашего  текущего
битмапа,  вокруг  каждой  точки складывать
четыре   соседние,   делить  на  четыре  и
полученый  результат  записывать  в данную
точку.
  После  этого  необходимо поменять буфера
местами  или  маркеры  ссылок  на  буфера.
Соответственно,   теперь   текущими  будут
второй  массив  битмапа  и  вторая таблица
смещений. И всё повторять заново.
  Теперь   несколько   советов  по  поводу
оптимизации.   Для   работы   с   таблицей
смещений  лучше  всего  подойдёт  стек. То
есть выталкиваете POP'ом из неё адрес и по
нему  берёте  цвет  точки  битмапа.  Я  её
совместил  с  процедурой  дизеринга. Вывод
изображения   делайте   поочерёдно  в  два
экрана. HALT можно и не ставить, всё равно
луч  незаметен,  а  скорость  быстрее  и в
турбе ускоряется. По поводу блюра. Деление
на   четыре  быстрее  делать  по  таблице.
Читать из массива битмапа можно не четыре,
а  три соседние точки. Четвёртая находится
в  аккумуляторе с предыдущего раза. Буфера
лучше сформировать так, чтобы младший байт
адреса  был  равен X, а старший Y. И тогда
нет  необходимости  каждый  раз  вычислять
адрес.
  Hу  вот пожалуй и всё, о чём я хотел вам
рассказать. Hадеюсь вы разберётесь со всем
этим  бредом  и  напишете  много  мажорных
эффектов :).

__________________________________________