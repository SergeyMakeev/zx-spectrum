; The Z80 supports three interrupt modes:
; IM 0: Executes an instruction that is placed on the data bus by a peripheral.
; IM 1: Jumps to address &0038
; IM 2: Uses an interrupt vector table, indexed by value on data bus.
; http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/interrupts
    DEVICE ZXSPECTRUM48
    SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION

stack_top: EQU 0xFFF0

Code_Start: EQU 0x8000
    ORG Code_Start

Main:
    LD A, 2         ; set border color to red(2)
    OUT (254), A

    ; Interrupt mode 2
    LD HL,Interrupt
    LD IX,0xFFF0
    LD (IX+04h),0xC3           		 ; Opcode for JP
    LD (IX+05h),L
    LD (IX+06h),H
    LD (IX+0Fh),0x18           		 ; Opcode for JR; this will do JR to FFF4h
    LD A,0x39
    LD I,A
    LD SP,0xFFF0
    IM 2
    EI

Loop:
    HALT
    JR Loop

Interrupt:
    DI                                      ; Disable interrupts 
    PUSH AF                                 ; Save all the registers on the stack
    PUSH BC                                 ; This is probably not necessary unless
    PUSH DE                                 ; we're looking at returning cleanly
    PUSH HL                                 ; back to BASIC at some point
    PUSH IX
    EXX
    EX AF,AF'
    PUSH AF
    PUSH BC
    PUSH DE
    PUSH HL
    PUSH IY

    LD A, 0         ; set border color to black
    OUT (254), A

    CALL Setka

    LD A, 1         ; set border color to blue
    OUT (254), A

    CALL WaveScroll

    LD A, 2         ; set border color to red(2)
    OUT (254), A


    POP IY                                  ; Restore all the registers
    POP HL
    POP DE
    POP BC
    POP AF
    EXX
    EX AF,AF'
    POP IX
    POP HL
    POP DE
    POP BC
    POP AF
    EI                                      ; Enable interrupts
    RET                                     ; And return

WaveScroll:
    LD (WaveScrollSavedSP), SP

WaveScrollCounter:
    LD A, 64                     ; 'animation' frame
    DEC A
    JP NZ, WaveScrollContinue
    LD A, 64

WaveScrollContinue:
    LD (WaveScrollCounter+1),A

    LD H, 0
    LD L, A
    ADD HL, HL                  ; hl = hl * 16
    ADD HL, HL
    ADD HL, HL
    ADD HL, HL
    LD DE, ScreeAddrBuffer2     ; precomputed table (screen addr here!)
    ADD HL, DE                  ; 

    LD SP, HL
    LD A, 255

    LD DE, SpriteData
    
    DUP 8
    POP HL                     ; fetch screen addr
    LD A, (DE)                 ; fetch sprite data (first byte) note: sprite is two bit wide!
    OR (HL)                    ;  write
    LD (HL), A                 ;     pixels (merge with existing screen pixels)
    INC DE
    INC L
    LD A, (DE)                 ; fetch sprite data (second byte)
    OR (HL)                    ;  write
    LD (HL), A                 ;     pixels (merge with existing screen pixels)
    INC DE
    EDUP

    LD SP, (WaveScrollSavedSP)
    RET

;-----------------------------

Setka:
    LD (SavedSP), SP
    LD SP, 0x5800               ; set stack to the end of the screen

CurrentCounter:
    LD A, 8                     ; loop counter. opcode: 3e 08
CurrentPatterAddr:    
    LD HL, FillPattern          ; fill pattern addres. opcode 21 XX XX (XXXX = 16 bit number)
    DEC A
    JR NZ, NotYetFinished

    ; loop reset
    LD A, 8
    LD HL, FillPattern-8
NotYetFinished:
    LD (CurrentCounter+1), A       ; note: self modifying code! (update counter)
    LD DE, 8
    ADD HL, DE
    LD (CurrentPatterAddr+1), HL   ; note self modifying code! (update address)

CurrentAddr:
    LD IX, HL
    LD BC,8 ; loop counter

InnerLoop:
    LD L,(IX+0)
    LD H, L

    ; 256 bytes * 8 = 2048 pixels = 8 lines
    DUP 128
    PUSH HL
    EDUP

    INC IX
    DEC BC         
    LD A,B         
    OR C           
    JP NZ, InnerLoop    


    LD SP, (SavedSP)
    RET

SavedSP:
    DB 0, 0

FillPattern:
    DB 0xAA, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00
    DB 0x00, 0x55, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40
    DB 0x20, 0x00, 0xAA, 0x00, 0x20, 0x00, 0x20, 0x00
    DB 0x00, 0x10, 0x00, 0x55, 0x00, 0x10, 0x00, 0x10
    DB 0x08, 0x00, 0x08, 0x00, 0xAA, 0x00, 0x08, 0x00
    DB 0x00, 0x04, 0x00, 0x04, 0x00, 0x55, 0x00, 0x04
    DB 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0xAA, 0x00
    DB 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x55



;-----------------------------

SpriteData:
    DB %00000000, %00000000
    DB %00000000, %01100110
    DB %00000000, %11111111
    DB %00000000, %11111111
    DB %00000000, %11111111
    DB %00000000, %01111110
    DB %00000000, %00111100
    DB %00000000, %00011000


WaveScrollSavedSP:
    DB 0, 0

    ;  0x4000
    ;  256x192 pixels (32x24 chars)
    ;  https://i.redd.it/zx-spectrum-48k-video-memory-layout-v0-gqg161nzf4f91.png?format=pjpg&s=5e079dbe91ee49fe253d5f39f080a7d8bf0d4fe8
    ; http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/screen-memory-layout
ScreeAddrBuffer2:
    LUA ALLPASS
        for step = 0, 64 do
            local k = (step / 64.0)             -- 0..1 range
            k = (k * 2.0) - 1.0                 -- -1..1 range
            k = k * math.pi                     -- -pi..pi range
            local cos_val = math.cos(k)         -- -1..1
            cos_val = (cos_val * 0.5) + 0.5     --  0..1 
            cos_val = cos_val * 56              -- 0..56 (amplitude)
            cos_val = 128 + cos_val             -- 128..184 (offset)
            cos_val = math.floor(cos_val + 0.5) -- floor (to integer)

            _pc(string.format("; ---- frame(%d) cos(%3.2f), y(%d) ----", step, k, cos_val))

            for i = 0, 7 do
                local x = 0
                local y = cos_val + i
                --local y = 184+i

                -- compute speccy screen address from x,y

                if x < 0 then
                  x = 0
                end

                if x >= 256 then
                  x = 255
                end

                if y < 0 then
                  y = 0
                end

                if y >= 192 then
                  y = 191
                end

                x = x & 31

                local y_b012 = y & 7
                local y_b345 = (y & 56) >> 3
                local y_b67 = (y & 192) >> 6
                
                local l = x | (y_b345 << 5)
                local h = 64 | y_b012 | (y_b67 << 3)

                _pc(string.format("DW 0x%02x%02x  ; %s", h, l, y))

            end
        end
    ENDLUA

Code_Length: EQU $-Code_Start+1

    SAVESNA "wave/wave.sna", Code_Start
