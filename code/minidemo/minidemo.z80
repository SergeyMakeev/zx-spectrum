; Memory map
; ------------------------------------------
;  Addr     Length        Desc
; ------------------------------------------
;  0x4000   0x1800        * Screen (pixels)
;  0x5800   0x0300        * Screen (attributes)
;  0x6000   0x1800        * Pre-scrolled font data (4 sprite banks)
;  0x7800   0x0040        Fill Pattern + scroller texts + aux data
;         ~896 bytes free
;  0x8000   ...           Code+data
;         ~800 bytes free
;  0x9200                 Precomputed tables
;         ~320 bytes free
;  0xC000   0x1C11        Music
;  0xDE00   0x1800        Pre-scrolled logo data (8 sprite banks)
;  0xF600   0x07e0        renegade screen              
;         ~376 bytes free
;  0xFF58   0xA8          * Reserved + stack
; ------------------------------------------
    DEVICE ZXSPECTRUM48
    SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION

stack_top: EQU 0xFFF0

    ORG 0x6000
SpriteData: DB 0    ;..................... a lot of data ...............
; 96 sprites(characters) * 16 bytes each * 4 (offset by two pixels) = 6144 bytes
; SpriteData+96*16*0 = offset(0)
; SpriteData+96*16*1 = offset(2)
; SpriteData+96*16*2 = offset(4)
; SpriteData+96*16*3 = offset(6)

;==========================================================================================================
;==========================================================================================================
;==========================================================================================================

Block1Start: EQU 0x7800
    ORG Block1Start


FillPattern:
    DB 0xAA, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00
    DB 0x00, 0x55, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40
    DB 0x20, 0x00, 0xAA, 0x00, 0x20, 0x00, 0x20, 0x00
    DB 0x00, 0x10, 0x00, 0x55, 0x00, 0x10, 0x00, 0x10
    DB 0x08, 0x00, 0x08, 0x00, 0xAA, 0x00, 0x08, 0x00
    DB 0x00, 0x04, 0x00, 0x04, 0x00, 0x55, 0x00, 0x04
    DB 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0xAA, 0x00
    DB 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x55

Text2:
    DB "        "
    DB "THIS HUMBLE DEMO IS DEDICATED TO ALL RENDERING PEOPLE IN THE WORLD! # # # THANK YOU ALL FOR DOING GREAT THINGS AND"
    DB " CONSTANTLY INSPIRING! # # # U ALL ROCK! # # #       "
	DB 0


WaveScrollScratch:
;   DB "AXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXZW"
    DB "                                 "

ScrollerText:
    DB "                             "
    DB "HELLO! HOLA! SERGEY MAKEEV IS PROUDLY  PRESENT TO YOU MY TRIBUTE TO ZX SPECTRUM MACHINE!   SPECCY RULEZ 4EVER! "
    DB "CODING: SERGEY MAKEEV     GRAPHICS: SERGEY MAKEEV AND IMAGINE SOFTWARE    MUSIC: JAROSLAW BYRCZYNSKI     "
    DB "KUDOS TO ALL ROBLOX PEOPLE AND ESPECIALLY TO ROBLOX RENDERING TEAM!  #  #  #   GREETINGS TO "
    DB "ZEUX, ARUSLAN, SIM0NSAYS, LOOK4WHILE, ANDSOFT, SHODAN, WRAITH, TAGVARD, RUDYBEAR, IRONPETER, DDIMA, LOYSO, WAT, TODACE, "
    DB "DAGGER, ART321, COOPERFEET, BOMBOM, ZEMIN, BAHO, SPAWNGARRET, ASTROLOGER, BANDURES, BINSTREAM, MUXAHUK, DARKMIKE, FRUSTUM, "
    DB "MAX PERMINOV, MAXX, DWALX AND MAY MANY OTHERS!        "
    DB "SPECIAL THANKS TO MY FAMILY! # # # AIDA, ARSENII, MATVEI, AND LEO ALEX! # # #   LOVE U GUYS!           "
    DB "THAT ALL FOLKS! THANK YOU FOR WATCHING!!!                                            "
    DB 0 


    ALIGN 256
    ; 160 bytes
    ALIGN 256
StarSprite:
    ; 0 (biggest star)
	DB 0,1,0,1,17,1,5,3              
	DB 191,3,5,1,17,1,0,1
	DB 0,0,0,0,16,0,64,128
	DB 250,128,64,0,16,0,0,0
    ; 32
	DB 0,0,0,1,1,9,5,3
	DB 63,3,5,9,1,1,0,0
	DB 0,0,0,0,0,32,64,128
	DB 240,128,64,32,0,0,0,0
    ; 64
	DB 0,0,0,0,0,1,1,3
	DB 15,3,1,1,0,0,0,0
	DB 0,0,0,0,0,0,0,128
    DB 224,128,0,0,0,0,0,0
    ;96 (smalles star)
	DB 0,0,0,0,0,0,0,1
	DB 3,1,0,0,0,0,0,0
	DB 0,0,0,0,0,0,0,0
	DB 128,0,0,0,0,0,0,0
    ;128 (none)
    DB 0,0,0,0,0,0,0,0
    DB 0,0,0,0,0,0,0,0
    DB 0,0,0,0,0,0,0,0
    DB 0,0,0,0,0,0,0,0


; 0x4000 = origin
; y * 32 + x
Star1S: EQU 0x4000+4*32+2                 ; y = 4, x = 2
Star2S: EQU 0x4000+1*32+28                ; y = 1, x = 28

Star3S: EQU 0x4000+1*32+4                 ; y = 1, x = 4

Star4S: EQU 0x4000+3*32+26                ; y = 3, x = 26

    ; 480 bytes
StarAnimTable:
    DW StarSprite+128, Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+96,  Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 3  (small)
    DW StarSprite+64,  Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 2
    DW StarSprite+32,  Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 1
    DW StarSprite,     Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 0  (big)
    DW StarSprite+32,  Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 1
    DW StarSprite+64,  Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 2
    DW StarSprite+96,  Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 3  (small)
    DW StarSprite+128, Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star1S, Star1S+32, Star1S+1, Star1S+1+32                  ; frame 4  (none/clear)

    DW StarSprite+128, Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+96,  Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 3  (small)
    DW StarSprite+64,  Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 2
    DW StarSprite+32,  Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 1
    DW StarSprite,     Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 0  (big)
    DW StarSprite+32,  Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 1
    DW StarSprite+64,  Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 2
    DW StarSprite+96,  Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 3  (small)
    DW StarSprite+128, Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star2S, Star2S+32, Star2S+1, Star2S+1+32                  ; frame 4  (none/clear)

    DW StarSprite+128, Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+96,  Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 3  (small)
    DW StarSprite+64,  Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 2
    DW StarSprite+32,  Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 1
    DW StarSprite,     Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 0  (big)
    DW StarSprite+32,  Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 1
    DW StarSprite+64,  Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 2
    DW StarSprite+96,  Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 3  (small)
    DW StarSprite+128, Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star3S, Star3S+32, Star3S+1, Star3S+1+32                  ; frame 4  (none/clear)

    DW StarSprite+128, Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+96,  Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 3  (small)
    DW StarSprite+64,  Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 2
    DW StarSprite+32,  Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 1
    DW StarSprite,     Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 0  (big)
    DW StarSprite+32,  Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 1
    DW StarSprite+64,  Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 2
    DW StarSprite+96,  Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 3  (small)
    DW StarSprite+128, Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 4  (none/clear)
    DW StarSprite+128, Star4S, Star4S+32, Star4S+1, Star4S+1+32                  ; frame 4  (none/clear)
StarAnimTableEnd:

TopLogo:
    DB 0x77, 0xb8, 0xcf, 0x50, 0x89, 0x92, 0xf7, 0xa8, 0x0c, 0x63, 0x38
    DB 0x84, 0x25, 0x08, 0x50, 0xda, 0x54, 0x84, 0x28, 0x12, 0xb4, 0x84
    DB 0x67, 0x39, 0x6e, 0x20, 0xab, 0xd8, 0xe7, 0x28, 0x04, 0xd1, 0x18
    DB 0x14, 0x29, 0x28, 0x20, 0x8a, 0x54, 0x84, 0x28, 0x08, 0x92, 0x04
    DB 0xe7, 0xa4, 0xcf, 0x20, 0x8a, 0x52, 0xf7, 0x90, 0x1e, 0x67, 0xb8


Block1Length: EQU $-Block1Start+1


;==========================================================================================================
;==========================================================================================================
;==========================================================================================================

Code_Start: EQU 0x8000
    ORG Code_Start

Main:

    CALL PreScrollLogoSprite
    CALL PreScrollFont


    DUP 16
    CALL atrFadeOut
    EI
    HALT
    HALT
    HALT
    HALT
    HALT
    EDUP


    CALL ClearScreen
    CALL CopyRenegadeToScreen
    CALL DrawTopLogo

    ; vortex tracker init address
    di
    call 0xc000
    ei


    CALL ResetText2

    ; Interrupt mode 2
    LD HL,Interrupt
    LD IX,0xFFF0
    LD (IX+04h),0xC3           		 ; Opcode for JP
    LD (IX+05h),L
    LD (IX+06h),H
    LD (IX+0Fh),0x18           		 ; Opcode for JR; this will do JR to FFF4h
    LD A,0x39
    LD I,A
    LD SP,0xFFF0
    IM 2
    EI

Loop:
    HALT
    JR Loop

Interrupt:
    DI                                      ; Disable interrupts 
    PUSH AF                                 ; Save all the registers on the stack
    PUSH BC                                 ; This is probably not necessary unless
    PUSH DE                                 ; we're looking at returning cleanly
    PUSH HL                                 ; back to BASIC at some point
    PUSH IX
    EXX
    EX AF,AF'
    PUSH AF
    PUSH BC
    PUSH DE
    PUSH HL
    PUSH IY

    ;LD A, 2         ; set border color 
    ;OUT (254), A


    CALL Setka

    ;LD A, 1         ; set border color
    ;OUT (254), A

    CALL WaveScroll

    ;LD A, 3         ; set border color
    ;OUT (254), A

    CALL PrintLetterIfNeed2

    ;LD A, 4         ; set border color
    ;OUT (254), A

    CALL ScrollAttrib

    ;LD A, 5         ; set border color
    ;OUT (254), A

    ; vortex tracker play address
    call 0xc005

    ;LD A, 6         ; set border color
    ;OUT (254), A

    CALL DrawLogo

    ;LD A, 2         ; set border color
    ;OUT (254), A

    CALL AttributeFlash

    ;LD A, 5         ; set border color
    ;OUT (254), A


    CALL StarFx

    ;LD A, 0         ; set border color
    ;OUT (254), A


    POP IY                                  ; Restore all the registers
    POP HL
    POP DE
    POP BC
    POP AF
    EXX
    EX AF,AF'
    POP IX
    POP HL
    POP DE
    POP BC
    POP AF
    EI                                      ; Enable interrupts
    RET                                     ; And return

ClearScreen:
    XOR  A 

    ; clear border
    OUT  (0xFE),A             

    ; clear pixels
    LD   HL, 0x4000
    LD   DE, 0x4001
    LD   BC, 0x17ff
    LD   (HL),A
    LDIR   


    ;clear attrs (in thirds)
    LD A, 7                  ; white
    LD   HL, 0x5800
    LD   DE, 0x5801
    LD   BC, 0xff
    LD   (HL),A
    LDIR   

    LD A, 0                  ; black
    LD   HL, 0x5900
    LD   DE, 0x5901
    LD   BC, 0xff
    LD   (HL),A
    LDIR   

    LD A, 6                  ; yellow
    LD   HL, 0x5A00
    LD   DE, 0x5A01
    LD   BC, 0xff
    LD   (HL),A
    LDIR   



    RET


;=============================================================

    MACRO PUT_ATTR_PIX dstAddr, srcAddr
    XOR A                 ; reset CF flag and clear A
    LD HL, srcAddr
    RL (HL)               ; CF <- [byte] <- CF
    JR NC, .EmptyPix
    LD A, (AttrColor)
.EmptyPix
    LD (dstAddr), A
    ENDM


;============================================================
; E = number of pixels to shift PLUS ONE!!  e.g, 1,2,3,4,5,6,7,8
PreScrollFontImpl:    
    LD HL, Font                     ; source 8 bit/character
    LD BC, 96*8                     ; 96 characters, 8 bytes each
.PreScrollLoop
    PUSH BC                         ; save loop counter
    PUSH DE                         ; save inner loop counter

    LD A, (HL)                      ; load original 8 pixels
    INC HL
    LD D, 0                         ; set hi-byte to zero 
;------------ scroll pixels
.PreScrollInnerLoop
    DEC E
    JR Z, .PreScrollBreakInnerLoop
    OR A                            ; clear CF flag 
    RL A                            ; CF <- [byte] <- CF   \
    RL D                            ; CF <- [byte] <- CF   /
    JR .PreScrollInnerLoop
;------------ scroll pixels
.PreScrollBreakInnerLoop
    ; write shifted pixels
    LD (IX), D
    INC IX
    LD (IX), A
    INC IX

    ; loop
    POP DE                          ; restore inner loop counter
    POP BC                          ; restore loop counter
    DEC BC         
    LD A,B         
    OR C           
    JP NZ, .PreScrollLoop    
    RET

PreScrollFont:
    LD E, 1                 ; num pixels to scroll (0)
    LD IX, SpriteData       ; destination 16 bit/character
    CALL PreScrollFontImpl
    LD E, 3                 ; num pixels to scroll (2)
    CALL PreScrollFontImpl
    LD E, 5                 ; num pixels to scroll (4)
    CALL PreScrollFontImpl
    LD E, 7                 ; num pixels to scroll (6)
    CALL PreScrollFontImpl
    RET

;============================================================
 
ScrollAttrib:

    ; attr starts 0x5800
    ; 32x24 attr positions

    ; scroll one line
    LD   HL, 0x5901
    LD   DE, 0x5900
    LD   BC, 255
    LDIR 

    ; print new pixels
    PUT_ATTR_PIX 0x591f, CharBuffer2+0
    PUT_ATTR_PIX 0x591f+32, CharBuffer2+1
    PUT_ATTR_PIX 0x591f+32+32, CharBuffer2+2
    PUT_ATTR_PIX 0x591f+32+32+32, CharBuffer2+3
    PUT_ATTR_PIX 0x591f+32+32+32+32, CharBuffer2+4
    PUT_ATTR_PIX 0x591f+32+32+32+32+32, CharBuffer2+5
    PUT_ATTR_PIX 0x591f+32+32+32+32+32+32, CharBuffer2+6
    PUT_ATTR_PIX 0x591f+32+32+32+32+32+32+32, CharBuffer2+7



    RET




PrintLetterIfNeed2:
    LD A, (Counter2)
    DEC A
    JR NZ,PrintLetterExit2
    LD A, 8
    LD (Counter2), A

	LD BC, (TextReadAddr2)       ; fetch + incerase current character address
	LD A, (BC)                  ; fetch character
    INC BC
    LD (TextReadAddr2), BC

    ; check for heart symbol (#)
    LD HL, AttrColor                
    CP 35
    JR Z, SetRedColor
    LD (HL), 32                    ; green
    ;LD (HL), 96                     ; bright green
    JR Cont
SetRedColor:    
    LD (HL), 16                    ; red
    ;LD (HL), 80                     ; bright red 


Cont:
	OR A
	JR Z, ResetText2             ; reset scroller if character is zero (loop)

	LD H, 0                    ; ld hl, a
	LD L, A
    
    ; sub hl, 32
    LD DE, 0xffe0              ; -32
    ADD HL, DE

	ADD HL, HL                 ; hl2 = hl + hl
	ADD HL, HL                 ; hl4 = hl2 + hl2
	ADD HL, HL                 ; hl8 = hl8 + hl8
	
	LD DE, Font                ; start of font
	ADD HL, DE                 ; HL = a specific letter
	LD DE, CharBuffer2
	LD BC, 8
	LDIR
        
    RET

PrintLetterExit2:
    LD (Counter2), A
    RET
ResetText2:
    LD HL, Text2
    LD (TextReadAddr2), HL
    RET


; ========================================================================
;
;  scroller here!!!!
;
; ========================================================================
WaveScroll:
    LD (WaveScrollRestoreSP+1), SP          ; save stack pointer

WaveScrollCounter: LD A, 64                  ; 'animation' frame
    DEC A                                    ; decrease anim frame
    JP NZ, WaveScrollContinue
    LD A, 64                                 ; reset animation

WaveScrollContinue:
    LD (WaveScrollCounter+1),A              ; update animation frame
    LD IX, WaveScrollScratch+32             ; current text addr (sprite indexes) (note: last sprite addr, since we are rendering backwards!)
    
    ;SpriteDataEntries

    LD H, 0                                 ; HL = anim frame
    LD L, A
    ;LD L, 0
    ADD HL, HL                              ; HL = HL * 16
    ADD HL, HL                              ; ScreeAddrBuffer2 = 8 precomputed screen addresses per character 
    ADD HL, HL                              ;   addres is 16-bit (2 bytes) = 8 * 2 = 16 bytes
    ADD HL, HL
    LD DE, ScreeAddrBuffer2                 ;
    ADD HL, DE                              ; HL = address where precomputed screen addreses are stored

    AND 3                                   ; mask anim frame to make it 0..3 (we only have 4 sprite banks = scroll by 2px)
    CALL Z, ScrollScratchBuffer 
    LD (SpriteBankSelector+2), A            ; update active sprite bank (by fixing +N in LD (IY+N) )
    LD (SpriteBankSelector2+2), A            ; update active sprite bank (by fixing +N in LD (IY+N) )
    LD (SpriteBankSelector3+2), A            ; update active sprite bank (by fixing +N in LD (IY+N) )
    LD IY, SpriteDataEntries                ; sprite bank entry table (only high byte of addres, since sprite banks are aligned)            

    LD SP, HL                               ; set stack pointer to precomputed screen addresses
                                            ; (since every time we pop value from the stack SP automatically updates
                                            ;  we don't need to do nothing in the inner loop)



;---------- last character (sprite) ---------
    LD BC, 32 ; current index

    LD A, (IX)                  ; load current character code (sprite index)
    SUB 32                      ; subtract 32 
    LD L, A                     ;
    LD H, 0                     ; hl = character code
    ADD HL, HL                  ;
    ADD HL, HL                  ;
    ADD HL, HL                  ; hl = hl * 16 (16 since sprite width = 16px )
    ADD HL, HL                  ;
SpriteBankSelector3: LD D, (IY+0) ; load high byte
    LD E, 0                      ; since all sprite banks are aligned E is always zero
    ; IX = text pointer
    ; HL = char offset
    ; BC = animation cycle
    ADD DE, HL                  ; actual sprite data
   
    ; --- draw single sprite ---
    DUP 7                      ; note: we use 8x7 font to save perf!
    POP HL                     ; fetch screen addr
    ADD HL, BC
    LD A, (DE)                 ; fetch sprite data (first byte) Note: sprite is two bytes wide!
    ;LD A,255
    OR (HL)                    ;  write
    LD (HL), A                 ;     pixels (merge with existing screen pixels)
    INC DE
    INC HL
;    LD A, (DE)                 ; fetch sprite data (second byte)
;    OR (HL)                    ;  write
;    LD (HL), A                 ;     pixels (merge with existing screen pixels)
    INC DE
    EDUP
    POP HL                      ; pop screen addr for last line (but do not draw it to save perf!)
    DEC IX

;----------
    LD BC, 31 ; loop counter

WaveScrollInnerLoop:
    LD A, (IX)                  ; load current character code (sprite index)
    SUB 32                      ; subtract 32 
    LD L, A                     ;
    LD H, 0                     ; hl = character code
    ADD HL, HL                  ;
    ADD HL, HL                  ;
    ADD HL, HL                  ; hl = hl * 16 (16 since sprite width = 16px )
    ADD HL, HL                  ;
SpriteBankSelector: LD D, (IY+0) ; load high byte
    LD E, 0                      ; since all sprite banks are aligned E is always zero
    ; IX = text pointer
    ; HL = char offset
    ; BC = animation cycle
    ADD DE, HL                  ; actual sprite data
   
    ; --- draw single sprite ---
    DUP 7                      ; note: we use 8x7 font to save perf!
    POP HL                     ; fetch screen addr
    ADD HL, BC
    LD A, (DE)                 ; fetch sprite data (first byte) Note: sprite is two bytes wide!
    OR (HL)                    ;  write
    LD (HL), A                 ;     pixels (merge with existing screen pixels)
    INC DE
    INC L
    LD A, (DE)                 ; fetch sprite data (second byte)
    OR (HL)                    ;  write
    LD (HL), A                 ;     pixels (merge with existing screen pixels)
    INC DE
    EDUP
    POP HL                      ; pop screen addr for last line (but do not draw it to save perf!)

    DEC IX
    DEC C
    JP NZ, WaveScrollInnerLoop

;----- first character (sprite, note we only need to draw half of it!!)
    LD A, (IX)                  ; load current character code (sprite index)
    SUB 32                      ; subtract 32 
    LD L, A                     ;
    LD H, 0                     ; hl = character code
    ADD HL, HL                  ;
    ADD HL, HL                  ;
    ADD HL, HL                  ; hl = hl * 16 (16 since sprite width = 16px )
    ADD HL, HL                  ;
SpriteBankSelector2: LD D, (IY+0) ; load high byte
    LD E, 0                      ; since all sprite banks are aligned E is always zero
    ; IX = text pointer
    ; HL = char offset
    ; BC = animation cycle
    ADD DE, HL                  ; actual sprite data
   
    ; --- draw single sprite ---
    DUP 7                      ; note: we use 8x7 font to save perf!
    POP HL                     ; fetch screen addr
    ADD HL, BC
;    LD A, (DE)                 ; fetch sprite data (first byte) Note: sprite is two bytes wide!
;    OR (HL)                    ;  write
;    LD (HL), A                 ;     pixels (merge with existing screen pixels)
    INC DE
    INC HL
    LD A, (DE)                 ; fetch sprite data (second byte)
    OR (HL)                    ;  write
    LD (HL), A                 ;     pixels (merge with existing screen pixels)
    INC DE
    EDUP
    POP HL                      ; pop screen addr for last line (but do not draw it to save perf!)

;-----    

WaveScrollRestoreSP:    LD SP, 0 ; restore stack pointer
    RET

ScrollScratchBuffer:
    PUSH AF
    EXX                         ; save BC, DE, HL to shadow registers
    LD DE, WaveScrollScratch
    LD HL, WaveScrollScratch+1
    LD BC, 32
    LDIR
CurrentScrollerText: LD HL, ScrollerText
    LD A, (HL)
    INC HL
    OR A
    JR NZ, ContinueAsNormal
    LD A, 32                  ; reset
    LD HL, ScrollerText       ;   scroller 
ContinueAsNormal:    
    LD (DE), A                       ; append to scratch
    LD (CurrentScrollerText+1), HL   ; move to the next character
    EXX                              ; restore BC, DE, HL from shadow registers
    POP AF
    RET
;---------------------------------------------------------------------------------------------------------
;=============================================================
; HL = src
; DE = dst
; BC = counter (NOTE!!! BC<=255)

CopyPreScrollLine:
    ; copy bytes
    PUSH BC
    PUSH DE
    LDIR   

    POP HL
    POP BC
    ADD HL, BC
    DEC HL
    LD B, C
    LD C, 0
    ;HL = end address

    ; scroll bits
    OR A        ; reset CF flag
.Loop   
    RL (HL)
    DEC HL
    DJNZ .Loop    
    RET

; HL = source address
; DE = destination address
PreScrollLogoSingleSprite:
    LD B, 48  ; 48 lines height
.VertLoop
    PUSH BC
    LD BC, 14
    PUSH HL
    PUSH DE
    PUSH BC
    CALL CopyPreScrollLine
    POP BC
    POP DE
    POP HL
    ADD HL, BC
    ADD DE, BC
    POP BC
    DJNZ .VertLoop
    RET


PreScrollLogoSprite:
    LD HL, LogoData+768*0
    LD DE, LogoData+768*1
    CALL PreScrollLogoSingleSprite

    LD HL, LogoData+768*1
    LD DE, LogoData+768*2
    CALL PreScrollLogoSingleSprite

    LD HL, LogoData+768*2
    LD DE, LogoData+768*3
    CALL PreScrollLogoSingleSprite

    LD HL, LogoData+768*3
    LD DE, LogoData+768*4
    CALL PreScrollLogoSingleSprite

    LD HL, LogoData+768*4
    LD DE, LogoData+768*5
    CALL PreScrollLogoSingleSprite

    LD HL, LogoData+768*5
    LD DE, LogoData+768*6
    CALL PreScrollLogoSingleSprite

    LD HL, LogoData+768*6
    LD DE, LogoData+768*7
    CALL PreScrollLogoSingleSprite

    RET

DrawLogo:

.AnimFrame: LD A, 65                  ; 'animation' frame (64..1)
    DEC A                             ; decrease anim frame
    JP NZ, .NoNeedToResetAnim
    LD A, 64                          ; reset animation

.NoNeedToResetAnim:
    LD (.AnimFrame+1), A              ; update animation frame
    DEC A                             ; 1..64 -> 0..63
    
    OR A                              ; reset CF flag
    RRA                               ; div 2 = 0..63 -> 0..31

    LD HL, SpriteTable0               
    ADD A, H                          ; take animation frame into account
    LD H, A


    LD (.SaveSP+1), SP ; save SP

    ; IX = pointer to sprite render table
    LD IX, HL

    DUP 46            ; note: do not draw two bottom sprite lines because of perf!
    LD L, (IX+0)      ; load src screen addr from memory
    LD H, (IX+1)      ;     one byte at a time
    LD SP, HL         ; move stack pointer to that screen memory

    ; step to then next table entry
    INC IX
    INC IX

    POP AF            ; read 2 bytes (16 pixels)
    POP BC            ; read 2 bytes (16 pixels)
    POP DE            ; read 2 bytes (16 pixels)
    POP HL            ; read 2 bytes (16 pixels)
    POP IY            ; read 2 bytes (16 pixels)     
    EXX               ; switch to shadow registers BC, DE, HL (note: we can not use HL)
    POP BC            ; read 2 bytes (16 pixels)
    POP DE            ; read 2 bytes (16 pixels)
    ;POP HL           ; we need that HL!!! (see below)
    LD L, (IX+0)      ; load dst screen addr from memory
    LD H, (IX+1)      ;     one byte at a time
    LD SP, HL         ; move stack pointer to that screen memory
    ;PUSH HL          ; we need that HL!!! (see above)
    PUSH DE           ; write 2 bytes
    PUSH BC           ; write 2 bytes
    EXX
    PUSH IY           ; write 2 bytes
    PUSH HL           ; write 2 bytes
    PUSH DE           ; write 2 bytes
    PUSH BC           ; write 2 bytes
    PUSH AF           ; write 2 bytes

    ; step to then next table entry
    INC IX
    INC IX
    EDUP

.SaveSP LD SP, 0 ; restore SP
    RET

;---------------------------------------------------------------------------------------------------------

AttributeFlash:
.Cntr: LD A, 29
    DEC A
    JR NZ, .Continue
    LD A, 28
.Continue
    LD (.Cntr+1), A   ; A = 1..28
    DEC A             ; A = 0..27
    LD (.CTableOffset+2), A                            ; adjust color table offset
    LD IX, ColorTable                                  ;
.CTableOffset    LD A, (IX+0)                          ; DD 7E 00
    DUP 6, Index_y
    DUP 15, Index_x
    LD (0x5800+Index_y*32+32+Index_x+8), A
    EDUP
    EDUP
    RET

ColorTable:
    ;DB 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7
    DB  65, 65, 65, 65, 66, 66, 66, 66, 67, 67, 67, 67, 68, 68, 68, 68, 69, 69, 69, 69, 70, 70, 70, 70, 71, 71, 71, 71

;---------------------------------------------------------------------------------------------------------
Setka:
    LD (SavedSP), SP
    LD SP, 0x5800               ; set stack to the end of the screen

CurrentCounter:
    LD A, 8                     ; loop counter. opcode: 3e 08
CurrentPatterAddr:    
    LD HL, FillPattern          ; fill pattern addres. opcode 21 XX XX (XXXX = 16 bit number)
    DEC A
    JR NZ, NotYetFinished

    ; loop reset
    LD A, 8
    LD HL, FillPattern-8
NotYetFinished:
    LD (CurrentCounter+1), A       ; note: self modifying code! (update counter)
    LD DE, 8
    ADD HL, DE
    LD (CurrentPatterAddr+1), HL   ; note self modifying code! (update address)

CurrentAddr:
    LD IX, HL
    LD BC,8 ; loop counter

InnerLoop:
    LD L,(IX+0)
    LD H, L

    ; 256 bytes * 8 = 2048 pixels = 8 lines
    DUP 128
    PUSH HL
    EDUP

    INC IX
    DEC BC         
    LD A,B         
    OR C           
    JP NZ, InnerLoop    


    LD SP, (SavedSP)
    RET

SavedSP:
    DB 0, 0


;---------------------

StarFx:

.DelayTimer: LD A, 5                   ; delay timer
    DEC A                              ; decrease delay timer
    JP NZ, .NoNeedToResetDelay
    LD A, 5                            ; reset delay timer
.NoNeedToResetDelay    
    LD (.DelayTimer+1), A              ; update delay timer
    RET NZ                             ; still waiting? -> return


.AnimFrame: LD A, 48+1                ; 'animation' frame (48..1)
    DEC A                             ; decrease anim frame
    JP NZ, .NoNeedToResetAnim
    LD A, 48                          ; reset animation

.NoNeedToResetAnim:
    LD (.AnimFrame+1), A              ; update animation frame
    DEC A                             ; 1..48 -> 0..47

    LD H, 0                           ; HL = A
    LD L, A
    ADD HL, HL                        ; HL = HL+HL = 2HL
    LD DE, HL
    ADD HL, HL                        ; HL = 2HL + 2HL = 4HL
    ADD HL, HL                        ; HL = 4HL + 4HL = 8HL
    ADD HL, DE                        ; HL = 8HL + 2HL = 10HL
    LD DE, StarAnimTable
    ADD HL, DE                        ; HL = pointer in the anim table


    LD (.RestoreSP+1), SP          ; save the stack pointer

    LD SP, HL
    POP IY                         ; sprite address
    POP HL                         ; screen addr 1
    POP BC                         ; screen addr 2
    EXX
    POP HL                         ; screen addr 3
    POP BC                         ; screen addr 4
    EXX

    LD SP, IY                      ; load sprite address
    ;LD HL, 0x4000
    DUP 4                          ; draw 8 lines
    POP DE
    LD (HL), E
    INC H
    LD (HL), D
    INC H
    EDUP

    LD HL, BC
    ;LD HL, 0x4000+32
    DUP 4                          ; draw 8 lines
    POP DE
    LD (HL), E
    INC H
    LD (HL), D
    INC H
    EDUP

    EXX                            ; switch to shadow registers

    ;LD HL, 0x4000+1
    DUP 4                          ; draw 8 lines
    POP DE
    LD (HL), E
    INC H
    LD (HL), D
    INC H
    EDUP

    LD HL, BC
    ;LD HL, 0x4000+1+32
    DUP 4                          ; draw 8 lines
    POP DE
    LD (HL), E
    INC H
    LD (HL), D
    INC H
    EDUP

    EXX                            ; switch back to normal registers
    
.RestoreSP:    LD SP, 0            ; restore stack pointer
    RET

;-----------------------------

DrawTopLogo:
    LD HL, TopLogo
    LD DE, 0x4000+10
    LD BC, 11
    LDIR   
    LD DE, 0x4000+256+10
    LD BC, 11
    LDIR   
    LD DE, 0x4000+256*2+10
    LD BC, 11
    LDIR   
    LD DE, 0x4000+256*3+10
    LD BC, 11
    LDIR   
    LD DE, 0x4000+256*4+10
    LD BC, 11
    LDIR   
    RET


;-----------------------------
CopyRenegadeToScreen:
    LD   HL, RenegadeBackground
    LD   DE, 0x4800
    LD   BC, 2016
    LDIR   
    RET

;    ORG 0x9200

;------------------------

; https://gist.github.com/ped7g/4bb94291ff379441494110f13825d956
;------------------------------------------------------------------------------
; ULA attributes "fade out" effect, going through PAPER/INK values,
; decrements them (individually) by 1 every iteration (call of routine)
;
; No input ; modifies AF, BC, D, HL
atrFadeOut:
    ld      hl,$5800
    ld      bc,(3<<8) | %00'001'001 ; B = 3, C = mask for INK/PAPER "1"
.doThird:               ; process 256 bytes (third of ULA screen)
    ld      a,(hl)      ; read current attribute
    ; for both PAPER and INK (individually), all three bits are merged into one by OR
    ld      d,a         ; the merged bits will land into "bottom" bit (b0 INK, b3 PAPER)
    rra                 ; setting those to "1" for non-zero INK/PAPER value
    or      d           ; and "0" for zero INK/PAPER - this will be then subtracted
    rra                 ; from current attribute
    or      d           ; *here* the bits 0 and 3 are "1" for non-zero INK and PAPER
    and     c           ; extract those bottom INK (+1)/PAPER (+8) bits into A
    ; subtract that value from current attribute, to decrement INK/PAPER individually
    sub     d           ; A = decrement - attribute
    neg                 ; A = attribute - decrement (new attribute value)
    ld      (hl),a      ; write the darkened attribute value
    inc     l
    jp      nz,.doThird ; process next attribute, until 256 of them were done
    inc     h
    djnz    .doThird    ; repeat for next third of ULA screen
    ret


PreComputedTablesStart:




TextReadAddr2:
    DB 0, 0

Counter2:
    DB 8

CharBuffer2:
    DB 0, 0, 0, 0, 0, 0, 0, 0

AttrColor:
    DB 10

WaveScrollSavedSP:
    DB 0, 0


CurrentScrollerTextAddr:
    DW ScrollerText

    ALIGN 256
    ;  0x4000
    ;  256x192 pixels (32x24 chars)
    ;  https://i.redd.it/zx-spectrum-48k-video-memory-layout-v0-gqg161nzf4f91.png?format=pjpg&s=5e079dbe91ee49fe253d5f39f080a7d8bf0d4fe8
    ; http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/screen-memory-layout
ScreeAddrBuffer2:
    LUA ALLPASS
        for tableNum = 0, 2 do                      -- we need two tables to wrap without clamping
            for step = 0, 64 do
                local k = (step / 64.0)             -- 0..1 range
                k = (k * 2.0) - 1.0                 -- -1..1 range
                k = k * math.pi                     -- -pi..pi range
                local cos_val = math.cos(k)         -- -1..1
                cos_val = (cos_val * 0.5) + 0.5     --  0..1 
                cos_val = cos_val * 56              -- 0..56 (amplitude)
                cos_val = 128 + cos_val             -- 128..184 (offset)
                cos_val = math.floor(cos_val + 0.5) -- floor (to integer)

                _pc(string.format("; ---- frame(%d) cos(%3.2f), y(%d) ----", step, k, cos_val))

                for i = 0, 7 do
                    local x = 0                  -- in characters 
                    local y = cos_val + i        -- in pixels
                    --local y = 184+i

                    -- y = 128 + i              -- debug (straight scroller)

                    -- compute speccy screen address from x,y

                    if x < 0 then x = 0 end

                    if x >= 32 then x = 31 end

                    if y < 0 then y = 0 end

                    if y >= 192 then y = 191 end

                    x = x & 31

                    local y_b012 = y & 7
                    local y_b345 = (y & 56) >> 3
                    local y_b67 = (y & 192) >> 6
                    
                    local l = x | (y_b345 << 5)
                    local h = 64 | y_b012 | (y_b67 << 3)
                    local hl = (h << 8) | l

                    -- note: hacky optimization! subtract 2 from hl (to avoid doing this at runtime!)
                    hl = hl - 1

                    _pc(string.format("DW 0x%04x  ; %s", hl, y))

                end
            end
        end
    ENDLUA
    ALIGN
ScreeAddrBuffer2End:    

SpriteDataEntries:
    LUA ALLPASS
        local banks = {0, 3, 2, 1}
        for _, sprite_bank in ipairs(banks) do
            local sprite_bank_offset = sprite_bank*1536
            local sprite_bank_addr = _c("SpriteData") + sprite_bank_offset
            if (sprite_bank_addr & 0xff) ~= 0 then
                sj.error("Sprite bank address must be aligned!")
            end
            local sprite_bank_addr_hi = (sprite_bank_addr >> 8)
            _pc(string.format("DB 0x%02x  ; offset = %d", sprite_bank_addr_hi, sprite_bank_offset))
        end
    ENDLUA
    ALIGN

Font:
    include "font.z80"

    LUA ALLPASS
        function generate_table_for_anim_frame(frame_index)

            local spriteBankAddr = _c("LogoData")
            local spriteBankStride = 768
            for line = 0, 47 do


                local k = (frame_index / 31.0)               -- to 0..1 range
                k = (k * 2.0) - 1.0                          -- -1..1 range
                k = k * math.pi                              -- -pi..pi range
                k = k + (line * 0.04)
                local cos_val = math.cos(k)                  -- -1..1
                local x_offset = math.floor(cos_val * 8)     -- amplitude & round to integer



                local _x = 70+x_offset + 14*8         -- 14*8 since we need to specify the right coord
                local y = 10 + line

                -- compute speccy screen address from x,y

                -- clamp
                if _x < 0 then _x = 0 end
                if _x >= 256 then _x = 255 end
                if y < 0 then y = 0 end
                if y >= 192 then y = 191 end

                -- compute screen address
                local xx0 = math.floor(_x/8)             -- char pos 0..31
                local xx1 = _x - (xx0 * 8)               -- pixel offset 0..7
                local spriteBankIndex = 0
                if xx1 > 0 then
                    xx0 = xx0 + 1
                    spriteBankIndex = 8 - xx1
                end

                local x = xx0 & 31
                local y_b012 = y & 7
                local y_b345 = (y & 56) >> 3
                local y_b67 = (y & 192) >> 6
                local l = x | (y_b345 << 5)
                local h = 64 | y_b012 | (y_b67 << 3)
                local screen_addr = (h << 8) | l
                local sprite_addr = spriteBankAddr + (spriteBankIndex * spriteBankStride) + (14 * line)
                _pc(string.format("DW 0x%04x, 0x%04x  ; %sx%s (%s, %s, %s, %s)", sprite_addr, screen_addr, x, y, _x, xx0, xx1, spriteBankIndex))

            end
        end
    ENDLUA


    LUA ALLPASS
        for anim_frame = 0, 31 do
            _pl("    ALIGN 256")
            _pl(string.format("SpriteTable%d", anim_frame))
            generate_table_for_anim_frame(anim_frame)
        end
    ENDLUA

PreComputedTablesEnd:


Code_Length: EQU $-Code_Start+1
;==========================================================================================================
;==========================================================================================================
;==========================================================================================================

Block2Start: EQU 0xc000
    ORG Block2Start
    INCHOB "startrip.$c"
Block2Length: EQU $-Block2Start+1

Block3Start: EQU 0xde00
    ORG 0xde00
LogoData:    
    include "logo.z80"
Block3Length: EQU $-Block3Start+1
; the logo size is 672 bytes (14*6 'characters' and every 'character' is 8 pixels height = 14*6*8 = 672 bytes)
; 672 aligned to 256 = 768 bytes
; 8 (pre)scrolled logos = 768 * 8 = 6144 bytes
; LogoData+6144 = end of logo data

Block4Start: EQU 0xf600
    ORG 0xf600
RenegadeBackground:    
    INCBIN "renegade.scr", 0, 2016

Block4Length: EQU $-Block4Start+1


    EMPTYTAP "minidemo/data01.tap"
    SAVETAP "minidemo/data01.tap", CODE, "DATA1", Block1Start, Block1Length

    EMPTYTAP "minidemo/code.tap"
    SAVETAP "minidemo/code.tap", CODE, "CODE", Code_Start, Code_Length, Code_Start

    EMPTYTAP "minidemo/data02.tap"
    SAVETAP "minidemo/data02.tap", CODE, "DATA2", Block2Start, Block2Length

    EMPTYTAP "minidemo/data03.tap"
    SAVETAP "minidemo/data03.tap", CODE, "DATA3", Block3Start, Block3Length

    EMPTYTAP "minidemo/data04.tap"
    SAVETAP "minidemo/data04.tap", CODE, "DATA4", Block4Start, Block4Length


    SAVESNA "minidemo/minidemo.sna", Code_Start
